
(eval-when (:load-toplevel)
  (sb-alien:load-shared-object "/sw/lib/libaquaterm.dylib"))

;;(declaim (inline aqt-...))

(sb-alien:define-alien-variable "AQTButtLineCapStyle" int)
(sb-alien:define-alien-variable "AQTSquareLineCapStyle" int)
(sb-alien:define-alien-variable "AQTAlignLeft" int)
(sb-alien:define-alien-variable "AQTAlignCenter" int)
(sb-alien:define-alien-variable "AQTAlignRight" int)
(sb-alien:define-alien-variable "AQTAlignMiddle" int)
(sb-alien:define-alien-variable "AQTAlignBaseline" int)
(sb-alien:define-alien-variable "AQTAlignBottom" int)
(sb-alien:define-alien-variable "AQTAlignTop" int)


(sb-alien:define-alien-routine "aqtInit" int)
(sb-alien:define-alien-routine "aqtTerminate" void)
(sb-alien:define-alien-routine "aqtOpenPlot" void (i int :in))
(sb-alien:define-alien-routine "aqtSelectPlot" void (i int :in))
(sb-alien:define-alien-routine "aqtSetPlotTitle" void (str c-string :in))
(sb-alien:define-alien-routine "aqtSetPlotSize" void (w float :in) (h float :in))
(sb-alien:define-alien-routine "aqtRenderPlot" void)
(sb-alien:define-alien-routine "aqtClearPlot" void)
(sb-alien:define-alien-routine "aqtClosePlot" void)
(sb-alien:define-alien-routine "aqtSetColor" void (r float :in) (g float :in) (b float :in))
(sb-alien:define-alien-routine "aqtSetFontname" void (str c-string :in))
(sb-alien:define-alien-routine "aqtSetFontsize" void (f float :in))
(sb-alien:define-alien-routine "aqtAddLabel" void (str c-string :in) (x float :in) (y float :in) (phi float :in) (align int :in))
(sb-alien:define-alien-routine "aqtSetLinestylePattern" void (pattern (* float) :in) (count int :in) (phase float :in))
(sb-alien:define-alien-routine "aqtSetLinestyleSolid" void)
(sb-alien:define-alien-routine "aqtSetLinewidth" void (f float :in))
(sb-alien:define-alien-routine "aqtMoveTo" void (x float :in) (y float :in))
(sb-alien:define-alien-routine "aqtAddLineTo" void (x float :in) (y float :in))
(sb-alien:define-alien-routine "aqtAddPolyline" void (xs (array float nil) :in) (ys (array float nil) :in) (count int :in))
(sb-alien:define-alien-routine "aqtMoveToVertex" void (x float :in) (y float :in))
(sb-alien:define-alien-routine "aqtAddEdgeToVertex" void (x float :in) (y float :in))
(sb-alien:define-alien-routine "aqtAddPolygon" void (xs (array float nil) :in) (ys (array float nil) :in) (pointcount int :in))
(sb-alien:define-alien-routine "aqtAddFilledRect" void (x float :in) (y float :in) (width float :in) (height float :in))


(defun init-aqt ()
  (let ((path (probe-file "/sw/lib/libaquaterm.dylib")))
    (if path
	(sb-alien:load-shared-object path))))


(defun test ()
  (aqtinit)
  (aqtopenplot 1)
  (aqtSetPlotSize 640.0 420.0)
  (aqtSetPlotTitle "SBCL Testbild")
  (aqtSetColor 0.0 0.0 0.0)
  (aqtSetFontName "Helvetica")
  (aqtSetFontsize 12.0)
  (aqtAddLabel "SBCL Testbild 640x420 pt" 4.0 412.0 0.0 AQTAlignLeft)
  ;; Rahmen malen
  (aqtMoveTo 20.0 20.0)
  (aqtAddLineTo 600.0 20.0)
  (aqtAddLineTo 600.0 400.0)
  (aqtAddLineTo 20.0 400.0)
  (aqtAddLineTo 20.0 20.0)
  (aqtAddLabel "Rahmen 600x400pt" 24.0 30.0 0.0 AQTAlignLeft)
  
  ;; Text
  (aqtSetFontname "Zapfino")
  (aqtSetFontsize 12.0)
  (aqtAddLabel "Zapfino 12pt" 320.0 104.0 0.0 AQTAlignLeft)


  (aqtRenderPlot)
  (aqtClosePlot)
  (aqtTerminate))

(defparameter *scen* '((a 0 0) (b 10 2) (c 1 28) (d  -28 -19) (e  -28 19) ))

(defun render-lr-scenario (points &key (line-division? t) (title "Plot") (halfplanes nil) (regions nil))
  (let* ((xs (mapcar #'(lambda (p)
			 (coerce (second p) 'single-float))
		     points))
	 (ys (mapcar #'(lambda (p)
			 (coerce (third p) 'single-float))
		     points))
	 (n (length points))
	 (minx (apply #'min xs))
	 (maxx (apply #'max xs))
	 (miny (apply #'min ys))
	 (maxy (apply #'max ys))
	 (dx (max 1.0 (- maxx minx)))
	 (dy (max 1.0 (- maxy miny)))
	 (scale (min (/ 210.0 dy) (/ 320.0 dx)))
	 (xl (+ (/ -160 scale) minx))
	 (xr (+ (/ 480 scale) minx)))
    (aqtinit)
    (aqtopenplot 1)
    (aqtSetPlotSize 640.0 420.0)
    (aqtSetPlotTitle title)
    (aqtSetFontName "Helvetica")
    (aqtSetFontsize 14.0)
    (aqtAddLabel (format nil "LR scenario with ~d point~:P" n) 10.0 410.0 0.0 AQTAlignLeft)
    
    (flet ((transform-x (x)
	     (coerce (+ 160 (* scale (- x minx))) 'single-float))
	   (transform-y (y)
	     (coerce (+ 105 (* scale (- y miny))) 'single-float)))
      (let ((hs (mapcar #'transform-x xs))
	    (vs (mapcar #'transform-y ys)))

	;; draw half-planes
	(mapc #'(lambda (hp)
		  (let* ((origin (first hp))			 
			 (normal (second hp))
			 (n (complex (first normal) (second normal)))
			 (ln (/ (* n #c(0 1)) (abs n))))
		    (if (zerop (second normal))
			(print "hp senkrecht --- geht noch nicht")
			(progn
			  (let* ((dist-left (/ (- (first origin) xl) (realpart ln)))
				 (dist-right (/ (- xr (first origin)) (realpart ln)))
				 (vl (transform-y (- (second origin) (* dist-left (imagpart ln)))))
				 (vr (transform-y (+ (second origin) (* dist-right (imagpart ln)))))
				 (dv (* 6 (signum (second normal)))))
			    (aqtSetColor 0.0 0.0 0.0)
			    (aqtSetLinewidth 1.0)
			    (aqtMoveTo 0.0 vl)
			    (aqtAddLineTo 640.0 vr)
			    ;(aqtSetLinewidth 4.0)
			    (dotimes (i 8)
			      (let ((c (- 0.9 (* 0.6 (/ (- 8 i) 8.0)))))
				(aqtSetColor c c c))
			      (aqtMoveTo 0.0 (coerce (+ (* (1+ i) dv) vl) 'single-float))
			      (aqtAddLineTo 640.0 (coerce (+ (* (1+ i) dv) vr) 'single-float)))

			      
			    )))))
	      halfplanes)

	;; draw regions
	(let ((color-phase 0.1))
	  (aqtSetLinewidth 6.0)
	  (mapc #'(lambda (reg)
		    (let ((xs (mapcar #'transform-x (mapcar #'car (car reg))))
			  (ys (mapcar #'transform-y (mapcar #'cadr (car reg))))
			  (rg (cis color-phase)))
		      (incf color-phase 0.5)
		      (aqtSetColor (realpart rg) (imagpart rg) 0.85)
		      (let ((n (length xs)))
			(with-alien ((axs (array single-float 64))
				     (ays (array single-float 64)))
			  (do ((i 0 (1+ i))
			       (xs-rest xs (cdr xs-rest))
			       (ys-rest ys (cdr ys-rest)))
			      ((or (= i 63)
				   (null xs-rest)))
			    (setf (deref axs i) (car xs-rest)
				  (deref ays i) (car ys-rest)))
			  (setf (deref axs (min 63 n)) (car xs)
				(deref ays (min 63 n)) (car ys))
			  (cond ((< 2 n) (aqtAddPolygon axs ays (min 64 (1+ n))))
				((= 2 n) 
				 (aqtMoveTo (deref axs 0) (deref ays 0))
				 (aqtAddLineTo (deref axs 1) (deref ays 1)))
				((= 1 n) 
				 (aqtMoveTo (- (deref axs 0) 4) (+ (deref ays 0) 4))
				 (aqtAddLineTo (+ (deref axs 0) 4) (- (deref ays 0) 4))
				 (aqtMoveTo (- (deref axs 0) 4) (- (deref ays 0) 4))
				 (aqtAddLineTo (+ (deref axs 0) 4) (+ (deref ays 0) 4))))))
		      (aqtSetColor 0.0 0.0 0.0)
		      (aqtAddLabel (second reg) (/ (apply #'+ xs) n) (/ (apply #'+ ys) n) 0.0 AQTAlignCenter)))
		regions))
	(aqtSetLinewidth 1.0)

	;; draw dividing lines
	(when line-division?
	  (aqtSetColor 0.6 0.6 0.6)
	  (mapc #'(lambda (h0 v0)
		    (mapc #'(lambda (h1 v1)
			      (unless (and (= h0 h1) (= v0 v1))
				(let ((dh (- h0 h1))
				      (dv (- v0 v1)))
				  (if (/= dh 0)
				      (let ((v-left (- v0 (* dv (/ h0 dh))))
					    (v-right (+ v0 (* dv (/ (- 640.0 h0) dh)))))
					(aqtMoveTo 0.0 v-left)
					(aqtAddLineTo 640.0 v-right))
				      (progn
					(aqtMoveTo h0 0.0)
					(aqtAddLineTo h0 420.0))))))
			  hs vs))
		hs vs))
	
	(aqtSetColor 0.0 0.0 0.0)      
	;; show points
	(mapc #'(lambda (p h v)
		  (let ((name (first p)))
		    (aqtAddFilledRect (- h 2.0) (- v 2.0) 4.0 4.0)
		    (aqtAddLabel (format nil "~a" name) (+ h 3.0) (+ v 3.0) 0.0 AQTAlignLeft)))
	      points hs vs)
	
	))
      

    (aqtRenderPlot)
    (aqtClosePlot)
    (aqtTerminate)))
