;;; ;;; dealing with angle intervals;;;(defun unconstrained-angle ()  :?)(defun unconstrained? (a)  (eq a :?))(defun impossible? (a)  (and (not (eq a :?))       (= 0 (third a))       (or (eq :open (second a))           (eq :open (fourth a)))))(defun add-angles (a1 a2)  (let ((a (if (or (unconstrained? a1)                   (unconstrained? a2))             :?             (let ((len (+ (third a1) (third a2))))               (if (>= (abs len) 1)                 :?                 (list (max -1 (min 1 (+ (first a1) (first a2))) )                       (if (or (eq (second a1) :open)                                (eq (second a2) :open))                         :open                         :closed)                       len                       (if (or (eq (fourth a1) :open)                                (eq (fourth a2) :open))                         :open                         :closed)))))))    (if (listp a)      (if (equal a '(1 :closed 0 :closed))        (list 0 :closed 0 :closed)        a)      a)))(defun subtract-angles (a1 a2)  (if (or (unconstrained? a1)          (unconstrained? a2)          (> 0 (- (first a1) (first a2))))    :?    (let ((len (- (third a2) (first a1))))      (if (>= (abs len) 1)        :?        (list (max -1 (min 1 (- (+ (third a1) (first a1)) (first a2))))              (if (or (eq (second a1) :open)                      (eq (second a2) :open))                :open                :closed)              len              (if (or (eq (fourth a1) :open)                       (eq (fourth a2) :open))                :open                :closed))))))(defun sub-angle (a1 a2)  (cond ((or (unconstrained? a1)             (unconstrained? a2)) :?)        ((and (= 0 (first a1))              (= 0 (first a2)))         a1)        ((and (= 1/2 (first a1))              (= 1/2 (first a2)))         a1)        (t :?)))                  (defun refine-angle (a1 a2)  (let ((a (cond ((unconstrained? a2) a1)                 ((unconstrained? a1) a2)                 ((or (< (+ (first a1) (third a1)) (first a2))                      (and (= (+ (first a1) (third a1)) (first a2))                           (or (eq :open (second a2))                               (eq :open (fourth a1)))))                  (list 0 :open 0 :open))                 ((or (< (+ (first a2) (third a2)) (first a1))                      (and (= (+ (first a2) (third a2)) (first a1))                  (or (eq :open (second a1))                      (eq :open (fourth a2)))))                  (list 0 :open 0 :open))                 (t (list (max (first a1) (first a2))                          (if (or (eq (second a1) :open)                                  (eq (second a2) :open))                            :open                            :closed)                          (min (third a1) (third a2))                          (if (or (eq (fourth a1) :open)                                   (eq (fourth a2) :open))                            :open                            :closed))))))    (if (listp a)      (if (equal a '(1 :closed 0 :closed))        (list 0 :closed 0 :closed)        a)      a)))(defun single-angle (v)  (list v :closed v :closed))(defun complementary-angle (a)  (if (eq a :?)    :?    (list (mod (- 1 (first a) (third a)) 1)          (fourth a)          (third a)          (second a))))(defun flip-cl (cl)  (if (eq cl :open)    :closed     :open))(defun opposing-side (a)  (if (eq a :?)    :?    (if (<= 0 (first a) 1/2)       (if (>= 1/2 (+ (first a) )(third a))        (list 1/2 (flip-cl (second a)) 1/2 (flip-cl (fourth a)))        :?)      (if (<= 1/2 (+ (first a) (third a)) 1)        (list 0 (flip-cl (second a)) 1/2 (flip-cl (fourth a)))        :?))));;;;;; data struct for storing angle constraints;;;(defstruct angle-array   object-vector  object-index-assoc  table)(defun init-angle-array (points)  (let ((n 0)        (alist ()))    (dolist (p points)      (push (cons p n) alist)      (incf n))    (make-angle-array :object-vector (coerce points 'vector)                      :object-index-assoc alist                      :table (make-array (list n n n) :initial-element (unconstrained-angle)))))(defun angle/indices (a i1 i2 i3)  (aref (angle-array-table a) i1 i2 i3))         (defun (setf angle/indices) (value angle-array &rest subscripts)  (setf (aref (angle-array-table angle-array) (first subscripts) (second subscripts) (third subscripts)) value))(defun angle/points (a p1 p2 p3)  (let ((alist (angle-array-object-index-assoc a)))    (angle/indices a (cdr (assoc p1 alist)) (cdr (assoc p2 alist)) (cdr (assoc p3 alist)))))(defun (setf angle/points) (value angle-array &rest points)  (let ((alist (angle-array-object-index-assoc angle-array)))    (flet ((index (p)             (cdr (assoc p alist))))      (setf (aref (angle-array-table angle-array) (index (first points)) (index (second points)) (index (third points))) value))))(defun accute-angle? (a)  (and (not (eq :? a))       (not (equal a '(0 :closed 0 :closed)))       (let ((max (+ (first a) (third a))))         (or (< max 1/2)             (and (= max 1/2) (eq (fourth a) :open))))))(defun angle-reasoning (points constraints &key (info? t))  (let ((angles (init-angle-array points))        (impossible? nil)        (zero-angle (single-angle 0)))    ;; Ang(Q P Q) = 0    (loop for p1 in points do          (loop for p2 in points do                (unless (eq p1 p2)                  (setf (angle/points angles p1 p2 p2) zero-angle))))    ;; fill in constraints    (dolist (c constraints)      (destructuring-bind (p q rel r) c        (case rel          (l (setf (angle/points angles p q r) (list 1/2 :open 1/2 :open)))          (r (setf (angle/points angles p q r) (list 0 :open 1/2 :open)))          (f (setf (angle/points angles p q r) zero-angle))          (i (setf (angle/points angles p r q) (list 1/2 :closed 0 :closed)))          (b (setf (angle/points angles p q r) zero-angle)))))    ;; do the reasoning    (let ((continue? t))      (loop while (and continue? (not impossible?)) do            (when info? (format t "~&;;~%;; STARTING ITERATION~%;;"))            (setq continue? nil)            (loop for p in points do                  (loop for q in points do                        (unless (eq p q)                          (loop for r in points do                                (unless (or (eq p r)                                             (eq q r))                                  ;; look at angle p-q-r vs r-p-q                                  (let* ((a-pqr (angle/points angles p q r))                                         (a-rqp (angle/points angles r q p))                                         (a-pqr/ref (refine-angle a-pqr (complementary-angle a-rqp)))                                         (a-rqp/ref (refine-angle a-rqp (complementary-angle a-pqr))))                                    (unless (equal a-pqr a-pqr/ref)                                      (when info?                                        (format t "~&[gegenwinkel] Ang(~A ~A ~A)=~A, Ang(~A ~A ~A)=~A  => Ang(~A ~A ~A)=~A  impossible? ~A"                                                p q r a-pqr                                                r q p a-rqp                                                p q r a-pqr/ref (impossible? a-pqr/ref)))                                      (setf (angle/points angles p q r) a-pqr/ref                                            a-pqr a-pqr/ref                                            continue? t                                            impossible? (or impossible? (impossible? a-pqr/ref))))                                    (unless (equal a-rqp a-rqp/ref)                                      (when info?                                        (format t "~&[gegenwinkel] Ang(~A ~A ~A)=~A, Ang(~A ~A ~A)=~A  => Ang(~A ~A ~A)=~A  impossible? ~A"                                                r q p a-rqp                                                p q r a-pqr                                                r q p a-rqp/ref (impossible? a-rqp/ref)))                                      (setf (angle/points angles r q p) a-rqp/ref                                            a-rqp a-rqp/ref                                            continue? t                                            impossible? (or impossible? (impossible? a-rqp/ref))))                                      (let* ((a-qpr (angle/points angles q p r))                                                                                      (a-qpr/ref (if (eq a-pqr :?)                                                        a-qpr                                                        (cond ((and (eq (first a-pqr) 0)                                                                    (eq (third a-pqr) 1/2)) (list 1/2 (second a-pqr) 1/2 (fourth a-pqr)))                                                              ((and (eq (first a-pqr) 1/2)                                                                    (eq (third a-pqr) 1/2)) (list 0 (second a-pqr) 1/2 (fourth a-pqr)))                                                              (t a-qpr)))))                                      (unless (equal a-qpr a-qpr/ref)                                        (when info?                                          (format t "~&[flipwinkel ] Ang(~A ~A ~A)=~A, Ang(~A ~A ~A)=~A  => Ang(~A ~A ~A)=~A impossible? ~A"                                                  q p r a-qpr                                                  p q r a-pqr                                                  q p r a-qpr/ref                                                   (impossible? a-qpr/ref)))                                        (setf (angle/points angles q p r) a-qpr/ref                                              impossible? (or impossible? (impossible? a-qpr/ref)))))                                    ;; propagate ABC -> ABD                                    (loop for s in points do                                          (unless (or (eq s r)                                                      (eq s p)                                                      (eq s q))                                            (let* ((a-pqs (angle/points angles p q s))                                                   (a-rqs (angle/points angles r q s))                                                   (a-prs (angle/points angles p r s))                                                   (a-pqs/ref (refine-angle a-pqs (add-angles a-pqr a-rqs))))                                              (when (and (accute-angle? a-pqr)                                                         (accute-angle? a-rqs)                                                         (accute-angle? a-prs))                                                (setq a-pqs/ref (refine-angle a-pqs/ref '(0 :open 1/2 :open))))                                              (unless (or (eq a-pqs/ref :?) (equal a-pqs/ref a-pqs))                                                (when info?                                                  (format t "~%[teilwinkel ] Ang(~A ~A ~A)=~A refined by Ang(~A ~A ~A)=~A and Ang(~A ~A ~A)=~A to ~A impossible? ~A"                                                          p q s a-pqs                                                          p q r a-pqr                                                          r q s a-rqs                                                          a-pqs/ref (impossible? a-pqs/ref)))                                                (setf continue? t                                                      impossible? (or impossible? (impossible? a-pqs/ref))                                                      (angle/points angles p q s) a-pqs/ref))                                                                                                                                                                                        )))                                    ;; look at triangle p q r                                    (let ((a-rpq (angle/points angles r p q))                                          (a-qrp (angle/points angles q r p)))                                      (when info? (format t "~&;; Triangle ~A ~A ~A : ~A + ~A + ~A = 1/2" p q r a-pqr a-rpq a-qrp))                                      ))))))))      (when (and info? impossible?)        (format t "~2%****** IMPOSSIBLE!!!  ******~2%")))    (when info?      (loop for p in points do            (loop for q in points do                  (unless (eq p q)                    (loop for r in points do                          (unless (or (eq r p) (eq r q))                            (format t "~%Ang ~A ~A ~A = ~A" p q r (angle/points angles p q r))))))))    (when info?      (loop for p in points do            (let ((rpts (remove p points)))              (format t "~2%Zentrum: ~A~%   |~{~2A |~}" p rpts)              (loop for q in rpts do                    (format t "~%~2A |" q)                    (loop for q2 in rpts do                          (format t "~2A |" (cond ((eq q q2) 0)                                                  ((accute-angle? (angle/points angles q p q2)) '+)                                                  ((accute-angle? (angle/points angles q2 p q)) '-)                                                  (t '?)))))              (format t "~%"))))          (when (and (not impossible?) (nthcdr 4 points))      (dolist (c points)        (let ((rest1 (remove c points)))          (dolist (p1 rest1)            (let ((rest2 (remove p1 rest1)))              (dolist (p2 rest2)                (let ((rest3 (remove p2 rest2)))                  (dolist (p3 rest3)                    (let ((rest4 (remove p3 rest3)))                      (dolist (p4 rest4)                        (when (and (accute-angle? (angle/points angles p1 c p2))                                   (accute-angle? (angle/points angles p1 c p3))                                   (accute-angle? (angle/points angles p2 c p3))                                   (accute-angle? (angle/points angles p2 c p4))                                   (accute-angle? (angle/points angles p4 c p3))                                   (not (accute-angle? (angle/points angles p1 c p4))))                          (setq impossible? t)                          (when info?                            (format t "~2%Inkonsistenz bei Zentrum ~A:~% ~A<~A, ~A<~A, ~A<~A, ~A<~A, ~A<~A~%-------------------------~%           ~A<~A IST NICHT GUELTIG!"                                    c p1 p2  p1 p3  p2 p3   p2 p4   p4 p3     p1 p4)))))))))))))                              impossible?))#|(angle-reasoning '(a b c d) '((a b l c) (a c l d) (b c r d) (a b r d)))(angle-reasoning '(a b c d e) '((A B R C) (A E R D) (D B R A) (D C R A) (D C R B) (D E R B) (D E L C) (E B R A) (E C R A) (E C R B)) :info? nil)(angle-reasoning '(a b c d) '((A B (L) C) (B C (R) D) (D B (L) A) (D C (R) A)))(angle-reasoning '(a b c d) '((A B (R) C) (B C (L) D) (D B (R) A) (D C (L) A)))|##|(let ((a-rqs/ref (if (and (accute-angle? a-pqs)                                                                        (accute-angle? a-pqr))                                                                 (refine-angle a-rqs (list 0 :open 1/2 :open))                                                                 :?)))                                                (unless (or (eq a-rqs/ref :?) (equal a-rqs a-rqs/ref))                                                  (format t "~%[teilwinkel2] Ang(~A ~A ~A)=~A refined by Ang(~A ~A ~A)=~A - Ang(~A ~A ~A)=~A to ~A impossible? ~A"                                                        r q s a-rqs                                                        p q s a-pqs                                                        p q r a-pqr                                                        a-rqs/ref (impossible? a-rqs/ref))                                                  (setf continue? t                                                        impossible? (or (impossible? a-rqs/ref))                                                        (angle/points angles r q s) a-rqs/ref)))|#